import {
    EquilibriumSolution,
    SystemConfig,
    ContinuationBranchData,
    ContinuationEigenvalue,
    LimitCycleBranchResponse,
    LimitCycleMeta
} from "./types";

export type CovariantLyapunovResponse = {
    dimension: number;
    checkpoints: number;
    times: number[];
    vectors: number[];
};

// We use require to load the WASM bindings generated by wasm-pack target nodejs
let wasmModule: any;

try {
    // Path relative to compiled index.js in dist/
    // Source is in cli/src, compiled to cli/dist
    // WASM pkg is in ../crates/fork_wasm/pkg
    wasmModule = require("../../crates/fork_wasm/pkg/fork_wasm.js");
} catch (e) {
    console.warn("Could not load WASM module. Simulation will fail.", e);
}

export class WasmBridge {
    instance: any;

    constructor(config: SystemConfig) {
        if (!wasmModule) throw new Error("WASM module not loaded");

        const { equations, params, paramNames, varNames, solver, type } = config;
        const systemType = type || "flow";

        this.instance = new wasmModule.WasmSystem(
            equations,
            new Float64Array(params),
            paramNames,
            varNames,
            solver,
            systemType
        );
    }

    set_state(state: number[]) {
        this.instance.set_state(new Float64Array(state));
    }

    get_state(): number[] {
        return Array.from(this.instance.get_state());
    }

    step(dt: number) {
        this.instance.step(dt);
    }

    get_t(): number {
        return this.instance.get_t();
    }

    set_t(t: number) {
        this.instance.set_t(t);
    }

    compute_jacobian(): number[] {
        return Array.from(this.instance.compute_jacobian());
    }

    solve_equilibrium(initialGuess: number[], maxSteps: number, dampingFactor: number): EquilibriumSolution {
        const result = this.instance.solve_equilibrium(
            new Float64Array(initialGuess),
            maxSteps,
            dampingFactor
        );
        return result as EquilibriumSolution;
    }

    computeLyapunovExponents(
        startState: number[],
        startTime: number,
        steps: number,
        dt: number,
        qrStride: number
    ): number[] {
        const result = this.instance.compute_lyapunov_exponents(
            new Float64Array(startState),
            startTime,
            steps,
            dt,
            qrStride
        );
        return Array.from(result);
    }

    computeCovariantLyapunovVectors(
        startState: number[],
        startTime: number,
        windowSteps: number,
        dt: number,
        qrStride: number,
        forwardTransient: number,
        backwardTransient: number
    ): CovariantLyapunovResponse {
        return this.instance.compute_covariant_lyapunov_vectors(
            new Float64Array(startState),
            startTime,
            windowSteps,
            dt,
            qrStride,
            forwardTransient,
            backwardTransient
        ) as CovariantLyapunovResponse;
    }

    compute_continuation(
        equilibriumState: number[],
        parameterName: string,
        settings: any,
        forward: boolean
    ): ContinuationBranchData {
        return this.instance.compute_continuation(
            new Float64Array(equilibriumState),
            parameterName,
            settings,
            forward
        ) as ContinuationBranchData;
    }

    extend_continuation(
        branchData: any,
        parameterName: string,
        settings: any,
        forward: boolean
    ): ContinuationBranchData {
        return this.instance.extend_continuation(
            branchData,
            parameterName,
            settings,
            forward
        ) as ContinuationBranchData;
    }

    compute_limit_cycle_from_hopf(
        hopfState: number[],
        hopfParam: number,
        parameterName: string,
        methodRequest: any,
        amplitude: number,
        settings: any,
        forward: boolean
    ): LimitCycleBranchResponse {
        return this.instance.continue_limit_cycle_from_hopf(
            new Float64Array(hopfState),
            hopfParam,
            parameterName,
            methodRequest,
            amplitude,
            settings,
            forward
        ) as LimitCycleBranchResponse;
    }

    extend_limit_cycle_branch(
        branchData: any,
        parameterName: string,
        meta: LimitCycleMeta,
        settings: any,
        forward: boolean
    ): LimitCycleBranchResponse {
        return this.instance.extend_limit_cycle_branch(
            branchData,
            parameterName,
            meta,
            settings,
            forward
        ) as LimitCycleBranchResponse;
    }

    computeEigenvalues(state: number[], parameterName: string, paramValue: number): ContinuationEigenvalue[] {
        const raw = this.instance.compute_equilibrium_eigenvalues(
            new Float64Array(state),
            parameterName,
            paramValue
        );
        return normalizeEigenvalues(raw);
    }
}

function normalizeEigenvalues(raw: unknown): ContinuationEigenvalue[] {
    if (!raw) return [];
    if (Array.isArray(raw)) {
        if (raw.length === 0) return [];
        if (typeof raw[0] === "number") {
            const nums = raw as number[];
            const result: ContinuationEigenvalue[] = [];
            for (let i = 0; i < nums.length; i += 2) {
                result.push({
                    re: nums[i] ?? 0,
                    im: nums[i + 1] ?? 0
                });
            }
            return result;
        }
        return raw.map((val: any) => {
            if (Array.isArray(val) && val.length >= 2) {
                return {
                    re: typeof val[0] === "number" ? val[0] : 0,
                    im: typeof val[1] === "number" ? val[1] : 0
                };
            }
            return {
                re: typeof val?.re === "number" ? val.re : Number(val?.re ?? 0),
                im: typeof val?.im === "number" ? val.im : Number(val?.im ?? 0)
            };
        });
    }

    if (ArrayBuffer.isView(raw)) {
        const nums = Array.from(raw as unknown as ArrayLike<number>);
        const result: ContinuationEigenvalue[] = [];
        for (let i = 0; i < nums.length; i += 2) {
            result.push({
                re: nums[i] ?? 0,
                im: nums[i + 1] ?? 0
            });
        }
        return result;
    }

    return [];
}
