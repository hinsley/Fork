import { EquilibriumSolution, SystemConfig, ContinuationBranchData } from "./types";

// We use require to load the WASM bindings generated by wasm-pack target nodejs
let wasmModule: any;

try {
    // Path relative to compiled index.js in dist/
    // Source is in cli/src, compiled to cli/dist
    // WASM pkg is in ../crates/fork_wasm/pkg
    wasmModule = require("../../crates/fork_wasm/pkg/fork_wasm.js");
} catch (e) {
    console.warn("Could not load WASM module. Simulation will fail.", e);
}

export class WasmBridge {
    instance: any;

    constructor(config: SystemConfig) {
        if (!wasmModule) throw new Error("WASM module not loaded");

        const { equations, params, paramNames, varNames, solver, type } = config;
        const systemType = type || "flow";

        this.instance = new wasmModule.WasmSystem(
            equations,
            new Float64Array(params),
            paramNames,
            varNames,
            solver,
            systemType
        );
    }

    set_state(state: number[]) {
        this.instance.set_state(new Float64Array(state));
    }

    get_state(): number[] {
        return Array.from(this.instance.get_state());
    }

    step(dt: number) {
        this.instance.step(dt);
    }

    get_t(): number {
        return this.instance.get_t();
    }

    set_t(t: number) {
        this.instance.set_t(t);
    }

    compute_jacobian(): number[] {
        return Array.from(this.instance.compute_jacobian());
    }

    solve_equilibrium(initialGuess: number[], maxSteps: number, dampingFactor: number): EquilibriumSolution {
        const result = this.instance.solve_equilibrium(
            new Float64Array(initialGuess),
            maxSteps,
            dampingFactor
        );
        return result as EquilibriumSolution;
    }

    computeLyapunovExponents(
        startState: number[],
        startTime: number,
        steps: number,
        dt: number,
        qrStride: number
    ): number[] {
        const result = this.instance.compute_lyapunov_exponents(
            new Float64Array(startState),
            startTime,
            steps,
            dt,
            qrStride
        );
        return Array.from(result);
    }

    compute_continuation(
        equilibriumState: number[],
        parameterName: string,
        settings: any,
        forward: boolean
    ): ContinuationBranchData {
        return this.instance.compute_continuation(
            new Float64Array(equilibriumState),
            parameterName,
            settings,
            forward
        ) as ContinuationBranchData;
    }

    extend_continuation(
        branchData: any,
        parameterName: string,
        settings: any,
        forward: boolean
    ): ContinuationBranchData {
        return this.instance.extend_continuation(
            branchData,
            parameterName,
            settings,
            forward
        ) as ContinuationBranchData;
    }
}
