import {
    EquilibriumSolution,
    SystemConfig,
    ContinuationBranchData,
    ContinuationEigenvalue,
    LimitCycleBranchResponse,
    LimitCycleMeta,
    ContinuationProgress,
    AnalysisProgress,
    EquilibriumSolveProgress
} from "./types";

export type CovariantLyapunovResponse = {
    dimension: number;
    checkpoints: number;
    times: number[];
    vectors: number[];
};

export type EquilibriumContinuationRunner = {
    run_steps(batchSize: number): ContinuationProgress;
    get_progress(): ContinuationProgress;
    is_done(): boolean;
    get_result(): ContinuationBranchData;
};

export type ContinuationRunner = {
    run_steps(batchSize: number): ContinuationProgress;
    get_progress(): ContinuationProgress;
    is_done(): boolean;
    get_result(): ContinuationBranchData;
};

export type Codim1CurveRunner = {
    run_steps(batchSize: number): ContinuationProgress;
    get_progress(): ContinuationProgress;
    is_done(): boolean;
    get_result(): any;
};

export type AnalysisRunner<T> = {
    run_steps(batchSize: number): AnalysisProgress;
    get_progress(): AnalysisProgress;
    is_done(): boolean;
    get_result(): T;
};

export type EquilibriumSolverRunner = {
    run_steps(batchSize: number): EquilibriumSolveProgress;
    get_progress(): EquilibriumSolveProgress;
    is_done(): boolean;
    get_result(): EquilibriumSolution;
};

// We use require to load the WASM bindings generated by wasm-pack target nodejs
let wasmModule: any;

try {
    // Path relative to compiled index.js in dist/
    // Source is in cli/src, compiled to cli/dist
    // WASM pkg is in ../crates/fork_wasm/pkg
    wasmModule = require("../../crates/fork_wasm/pkg/fork_wasm.js");
} catch (e) {
    console.warn("Could not load WASM module. Simulation will fail.", e);
}

export class WasmBridge {
    instance: any;
    private readonly config: SystemConfig;

    constructor(config: SystemConfig) {
        if (!wasmModule) throw new Error("WASM module not loaded");

        const { equations, params, paramNames, varNames, solver, type } = config;
        const systemType = type || "flow";

        this.config = {
            ...config,
            equations: [...equations],
            params: [...params],
            paramNames: [...paramNames],
            varNames: [...varNames]
        };

        this.instance = new wasmModule.WasmSystem(
            equations,
            new Float64Array(params),
            paramNames,
            varNames,
            solver,
            systemType
        );
    }

    createEquilibriumContinuationRunner(
        equilibriumState: number[],
        parameterName: string,
        mapIterations: number,
        settings: any,
        forward: boolean
    ): EquilibriumContinuationRunner {
        if (!wasmModule) throw new Error("WASM module not loaded");

        return new wasmModule.WasmEquilibriumRunner(
            this.config.equations,
            new Float64Array(this.config.params),
            this.config.paramNames,
            this.config.varNames,
            this.config.type || "flow",
            mapIterations,
            new Float64Array(equilibriumState),
            parameterName,
            settings,
            forward
        ) as EquilibriumContinuationRunner;
    }

    createLimitCycleContinuationRunner(
        setup: any,
        parameterName: string,
        settings: any,
        forward: boolean
    ): ContinuationRunner {
        if (!wasmModule) throw new Error("WASM module not loaded");

        return new wasmModule.WasmLimitCycleRunner(
            this.config.equations,
            new Float64Array(this.config.params),
            this.config.paramNames,
            this.config.varNames,
            this.config.type || "flow",
            setup,
            parameterName,
            settings,
            forward
        ) as ContinuationRunner;
    }

    createHomoclinicContinuationRunner(
        setup: any,
        settings: any,
        forward: boolean
    ): ContinuationRunner {
        if (!wasmModule) throw new Error("WASM module not loaded");

        return new wasmModule.WasmHomoclinicRunner(
            this.config.equations,
            new Float64Array(this.config.params),
            this.config.paramNames,
            this.config.varNames,
            setup,
            settings,
            forward
        ) as ContinuationRunner;
    }

    createHomotopySaddleContinuationRunner(
        setup: any,
        settings: any,
        forward: boolean
    ): ContinuationRunner {
        if (!wasmModule) throw new Error("WASM module not loaded");

        return new wasmModule.WasmHomotopySaddleRunner(
            this.config.equations,
            new Float64Array(this.config.params),
            this.config.paramNames,
            this.config.varNames,
            setup,
            settings,
            forward
        ) as ContinuationRunner;
    }

    createContinuationExtensionRunner(
        branchData: ContinuationBranchData,
        parameterName: string,
        mapIterations: number,
        settings: any,
        forward: boolean
    ): ContinuationRunner {
        if (!wasmModule) throw new Error("WASM module not loaded");

        const useCodim1 = isCodim1BranchType((branchData as any)?.branch_type);
        const Runner = useCodim1
            ? wasmModule.WasmCodim1CurveExtensionRunner
            : wasmModule.WasmContinuationExtensionRunner;

        return new Runner(
            this.config.equations,
            new Float64Array(this.config.params),
            this.config.paramNames,
            this.config.varNames,
            this.config.type || "flow",
            mapIterations,
            branchData,
            parameterName,
            settings,
            forward
        ) as ContinuationRunner;
    }

    createFoldCurveRunner(
        foldState: number[],
        param1Name: string,
        param1Value: number,
        param2Name: string,
        param2Value: number,
        mapIterations: number,
        settings: any,
        forward: boolean
    ): Codim1CurveRunner {
        if (!wasmModule) throw new Error("WASM module not loaded");

        return new wasmModule.WasmFoldCurveRunner(
            this.config.equations,
            new Float64Array(this.config.params),
            this.config.paramNames,
            this.config.varNames,
            this.config.type || "flow",
            mapIterations,
            new Float64Array(foldState),
            param1Name,
            param1Value,
            param2Name,
            param2Value,
            settings,
            forward
        ) as Codim1CurveRunner;
    }

    createHopfCurveRunner(
        hopfState: number[],
        hopfOmega: number,
        param1Name: string,
        param1Value: number,
        param2Name: string,
        param2Value: number,
        mapIterations: number,
        settings: any,
        forward: boolean
    ): Codim1CurveRunner {
        if (!wasmModule) throw new Error("WASM module not loaded");

        return new wasmModule.WasmHopfCurveRunner(
            this.config.equations,
            new Float64Array(this.config.params),
            this.config.paramNames,
            this.config.varNames,
            this.config.type || "flow",
            mapIterations,
            new Float64Array(hopfState),
            hopfOmega,
            param1Name,
            param1Value,
            param2Name,
            param2Value,
            settings,
            forward
        ) as Codim1CurveRunner;
    }

    createLPCCurveRunner(
        lcState: number[],
        period: number,
        param1Name: string,
        param1Value: number,
        param2Name: string,
        param2Value: number,
        ntst: number,
        ncol: number,
        settings: any,
        forward: boolean
    ): Codim1CurveRunner {
        if (!wasmModule) throw new Error("WASM module not loaded");

        return new wasmModule.WasmLPCCurveRunner(
            this.config.equations,
            new Float64Array(this.config.params),
            this.config.paramNames,
            this.config.varNames,
            new Float64Array(lcState),
            period,
            param1Name,
            param1Value,
            param2Name,
            param2Value,
            ntst,
            ncol,
            settings,
            forward
        ) as Codim1CurveRunner;
    }

    createPDCurveRunner(
        lcState: number[],
        period: number,
        param1Name: string,
        param1Value: number,
        param2Name: string,
        param2Value: number,
        ntst: number,
        ncol: number,
        settings: any,
        forward: boolean
    ): Codim1CurveRunner {
        if (!wasmModule) throw new Error("WASM module not loaded");

        return new wasmModule.WasmPDCurveRunner(
            this.config.equations,
            new Float64Array(this.config.params),
            this.config.paramNames,
            this.config.varNames,
            new Float64Array(lcState),
            period,
            param1Name,
            param1Value,
            param2Name,
            param2Value,
            ntst,
            ncol,
            settings,
            forward
        ) as Codim1CurveRunner;
    }

    createNSCurveRunner(
        lcState: number[],
        period: number,
        param1Name: string,
        param1Value: number,
        param2Name: string,
        param2Value: number,
        initialK: number,
        ntst: number,
        ncol: number,
        settings: any,
        forward: boolean
    ): Codim1CurveRunner {
        if (!wasmModule) throw new Error("WASM module not loaded");

        return new wasmModule.WasmNSCurveRunner(
            this.config.equations,
            new Float64Array(this.config.params),
            this.config.paramNames,
            this.config.varNames,
            new Float64Array(lcState),
            period,
            param1Name,
            param1Value,
            param2Name,
            param2Value,
            initialK,
            ntst,
            ncol,
            settings,
            forward
        ) as Codim1CurveRunner;
    }

    createLyapunovRunner(
        startState: number[],
        startTime: number,
        steps: number,
        dt: number,
        qrStride: number
    ): AnalysisRunner<number[]> {
        if (!wasmModule) throw new Error("WASM module not loaded");

        return new wasmModule.WasmLyapunovRunner(
            this.config.equations,
            new Float64Array(this.config.params),
            this.config.paramNames,
            this.config.varNames,
            this.config.solver,
            new Float64Array(startState),
            startTime,
            steps,
            dt,
            qrStride
        ) as AnalysisRunner<number[]>;
    }

    createCovariantLyapunovRunner(
        startState: number[],
        startTime: number,
        dt: number,
        qrStride: number,
        windowSteps: number,
        forwardTransient: number,
        backwardTransient: number
    ): AnalysisRunner<CovariantLyapunovResponse> {
        if (!wasmModule) throw new Error("WASM module not loaded");

        return new wasmModule.WasmCovariantLyapunovRunner(
            this.config.equations,
            new Float64Array(this.config.params),
            this.config.paramNames,
            this.config.varNames,
            this.config.solver,
            new Float64Array(startState),
            startTime,
            dt,
            qrStride,
            windowSteps,
            forwardTransient,
            backwardTransient
        ) as AnalysisRunner<CovariantLyapunovResponse>;
    }

    createEquilibriumSolverRunner(
        initialGuess: number[],
        maxSteps: number,
        dampingFactor: number,
        mapIterations: number
    ): EquilibriumSolverRunner {
        if (!wasmModule) throw new Error("WASM module not loaded");

        return new wasmModule.WasmEquilibriumSolverRunner(
            this.config.equations,
            new Float64Array(this.config.params),
            this.config.paramNames,
            this.config.varNames,
            this.config.type || "flow",
            mapIterations,
            new Float64Array(initialGuess),
            maxSteps,
            dampingFactor
        ) as EquilibriumSolverRunner;
    }

    set_state(state: number[]) {
        this.instance.set_state(new Float64Array(state));
    }

    get_state(): number[] {
        return Array.from(this.instance.get_state());
    }

    step(dt: number) {
        this.instance.step(dt);
    }

    get_t(): number {
        return this.instance.get_t();
    }

    set_t(t: number) {
        this.instance.set_t(t);
    }

    compute_jacobian(): number[] {
        return Array.from(this.instance.compute_jacobian());
    }

    solve_equilibrium(initialGuess: number[], maxSteps: number, dampingFactor: number, mapIterations: number): EquilibriumSolution {
        const result = this.instance.solve_equilibrium(
            new Float64Array(initialGuess),
            maxSteps,
            dampingFactor,
            mapIterations
        );
        return result as EquilibriumSolution;
    }

    computeLyapunovExponents(
        startState: number[],
        startTime: number,
        steps: number,
        dt: number,
        qrStride: number
    ): number[] {
        const result = this.instance.compute_lyapunov_exponents(
            new Float64Array(startState),
            startTime,
            steps,
            dt,
            qrStride
        );
        return Array.from(result);
    }

    computeCovariantLyapunovVectors(
        startState: number[],
        startTime: number,
        windowSteps: number,
        dt: number,
        qrStride: number,
        forwardTransient: number,
        backwardTransient: number
    ): CovariantLyapunovResponse {
        return this.instance.compute_covariant_lyapunov_vectors(
            new Float64Array(startState),
            startTime,
            windowSteps,
            dt,
            qrStride,
            forwardTransient,
            backwardTransient
        ) as CovariantLyapunovResponse;
    }

    compute_continuation(
        equilibriumState: number[],
        parameterName: string,
        mapIterations: number,
        settings: any,
        forward: boolean
    ): ContinuationBranchData {
        return this.instance.compute_continuation(
            new Float64Array(equilibriumState),
            parameterName,
            mapIterations,
            settings,
            forward
        ) as ContinuationBranchData;
    }

    extend_continuation(
        branchData: any,
        parameterName: string,
        mapIterations: number,
        settings: any,
        forward: boolean
    ): ContinuationBranchData {


        // Normalize branch_type for Wasm (Rust expects internally tagged enum)
        const normalizedBranch = { ...branchData };

        // Debugging: Log what we are receiving
        // console.log("Extending branch with type:", normalizedBranch.branch_type);

        if (typeof normalizedBranch.branch_type === 'string') {
            const typeStr = (normalizedBranch.branch_type as string).toLowerCase();

            if (typeStr === 'equilibrium') {
                normalizedBranch.branch_type = { type: 'Equilibrium' };
            } else if (typeStr === 'limit_cycle') {
                // Attempt to recover LC config if possible, or assume it's lost and this will fail later
                // But typically LC branches are created with objects.
                // This handles legacy/string cases if any exist.
                // For now, if it's 'limit_cycle' string, we can't easily reconstruct without ntst/ncol.
                // Assuming standard flow creates objects.
            }
        } else if (!normalizedBranch.branch_type) {
            // Default to Equilibrium if missing

            normalizedBranch.branch_type = { type: 'Equilibrium' };
        }



        return this.instance.extend_continuation(
            normalizedBranch,
            parameterName,
            mapIterations,
            settings,
            forward
        ) as ContinuationBranchData;
    }

    compute_limit_cycle_from_hopf(
        hopfState: number[],
        hopfParam: number,
        parameterName: string,
        methodRequest: any,
        amplitude: number,
        settings: any,
        forward: boolean
    ): LimitCycleBranchResponse {
        return this.instance.continue_limit_cycle_from_hopf(
            new Float64Array(hopfState),
            hopfParam,
            parameterName,
            methodRequest,
            amplitude,
            settings,
            forward
        ) as LimitCycleBranchResponse;
    }

    extend_limit_cycle_branch(
        branchData: any,
        parameterName: string,
        meta: LimitCycleMeta,
        settings: any,
        forward: boolean
    ): LimitCycleBranchResponse {
        return this.instance.extend_limit_cycle_branch(
            branchData,
            parameterName,
            meta,
            settings,
            forward
        ) as LimitCycleBranchResponse;
    }

    computeEigenvalues(state: number[], parameterName: string, mapIterations: number, paramValue: number): ContinuationEigenvalue[] {
        const raw = this.instance.compute_equilibrium_eigenvalues(
            new Float64Array(state),
            parameterName,
            mapIterations,
            paramValue
        );
        return normalizeEigenvalues(raw);
    }

    /**
     * Initializes a limit cycle guess from a Hopf bifurcation point.
     */
    initLCFromHopf(
        hopfState: number[],
        parameterName: string,
        paramValue: number,
        amplitude: number,
        ntst: number,
        ncol: number
    ): any {
        return this.instance.init_lc_from_hopf(
            new Float64Array(hopfState),
            parameterName,
            paramValue,
            amplitude,
            ntst,
            ncol
        );
    }

    /**
     * Initializes a limit cycle guess from a computed orbit.
     * The orbit should have converged to a stable limit cycle.
     * 
     * @param orbitTimes - Time values from the orbit
     * @param orbitStates - State vectors at each time point (as 2D array)
     * @param paramValue - Current value of the continuation parameter
     * @param ntst - Number of mesh intervals
     * @param ncol - Collocation points per interval
     * @param tolerance - Tolerance for cycle detection (recurrence)
     */
    initLCFromOrbit(
        orbitTimes: number[],
        orbitStates: number[][],
        paramValue: number,
        ntst: number,
        ncol: number,
        tolerance: number
    ): any {
        // Flatten the 2D orbit states into 1D array
        const flatStates = orbitStates.flat();

        return this.instance.init_lc_from_orbit(
            new Float64Array(orbitTimes),
            new Float64Array(flatStates),
            paramValue,
            ntst,
            ncol,
            tolerance
        );
    }

    /**
     * Initializes a period-doubled limit cycle from a period-doubling bifurcation.
     * Takes the LC state at the PD point and constructs a doubled-period initial guess.
     * 
     * @param lcState - Flattened collocation state at the PD point [mesh, stages, period]
     * @param parameterName - Name of the continuation parameter
     * @param paramValue - Parameter value at the PD point
     * @param ntst - Number of mesh intervals in the source LC
     * @param ncol - Collocation points per interval
     * @param amplitude - Perturbation amplitude for stepping onto the new branch
     */
    initLCFromPD(
        lcState: number[],
        parameterName: string,
        paramValue: number,
        ntst: number,
        ncol: number,
        amplitude: number
    ): any {
        return this.instance.init_lc_from_pd(
            new Float64Array(lcState),
            parameterName,
            paramValue,
            ntst,
            ncol,
            amplitude
        );
    }

    /**
     * Initializes a period-doubled map cycle seed from a period-doubling point.
     *
     * @param pdState - State at the PD point
     * @param parameterName - Name of the continuation parameter
     * @param paramValue - Parameter value at the PD point
     * @param mapIterations - Cycle length of the source branch
     * @param amplitude - Perturbation amplitude for stepping onto the new branch
     */
    initMapCycleFromPD(
        pdState: number[],
        parameterName: string,
        paramValue: number,
        mapIterations: number,
        amplitude: number
    ): number[] {
        return this.instance.init_map_cycle_from_pd(
            new Float64Array(pdState),
            parameterName,
            paramValue,
            mapIterations,
            amplitude
        ) as number[];
    }

    /**
     * Continues a limit cycle from an initial guess.
     */
    continueLimitCycle(
        setup: any,
        parameterName: string,
        settings: any,
        forward: boolean
    ): ContinuationBranchData {
        return this.instance.compute_limit_cycle_continuation(
            setup,
            parameterName,
            settings,
            forward
        ) as ContinuationBranchData;
    }

    initHomoclinicFromLargeCycle(
        lcState: number[],
        sourceNtst: number,
        sourceNcol: number,
        parameterName: string,
        param2Name: string,
        targetNtst: number,
        targetNcol: number,
        freeTime: boolean,
        freeEps0: boolean,
        freeEps1: boolean
    ): any {
        return this.instance.init_homoclinic_from_large_cycle(
            new Float64Array(lcState),
            sourceNtst,
            sourceNcol,
            parameterName,
            param2Name,
            targetNtst,
            targetNcol,
            freeTime,
            freeEps0,
            freeEps1
        );
    }

    initHomoclinicFromHomoclinic(
        pointState: number[],
        sourceNtst: number,
        sourceNcol: number,
        sourceFreeTime: boolean,
        sourceFreeEps0: boolean,
        sourceFreeEps1: boolean,
        sourceFixedTime: number,
        sourceFixedEps0: number,
        sourceFixedEps1: number,
        parameterName: string,
        param2Name: string,
        targetNtst: number,
        targetNcol: number,
        freeTime: boolean,
        freeEps0: boolean,
        freeEps1: boolean
    ): any {
        return this.instance.init_homoclinic_from_homoclinic(
            new Float64Array(pointState),
            sourceNtst,
            sourceNcol,
            sourceFreeTime,
            sourceFreeEps0,
            sourceFreeEps1,
            sourceFixedTime,
            sourceFixedEps0,
            sourceFixedEps1,
            parameterName,
            param2Name,
            targetNtst,
            targetNcol,
            freeTime,
            freeEps0,
            freeEps1
        );
    }

    initHomotopySaddleFromEquilibrium(
        equilibriumState: number[],
        parameterName: string,
        param2Name: string,
        ntst: number,
        ncol: number,
        eps0: number,
        eps1: number,
        time: number,
        eps1Tol: number
    ): any {
        return this.instance.init_homotopy_saddle_from_equilibrium(
            new Float64Array(equilibriumState),
            parameterName,
            param2Name,
            ntst,
            ncol,
            eps0,
            eps1,
            time,
            eps1Tol
        );
    }

    initHomoclinicFromHomotopySaddle(
        stageDState: number[],
        sourceNtst: number,
        sourceNcol: number,
        parameterName: string,
        param2Name: string,
        targetNtst: number,
        targetNcol: number,
        freeTime: boolean,
        freeEps0: boolean,
        freeEps1: boolean
    ): any {
        return this.instance.init_homoclinic_from_homotopy_saddle(
            new Float64Array(stageDState),
            sourceNtst,
            sourceNcol,
            parameterName,
            param2Name,
            targetNtst,
            targetNcol,
            freeTime,
            freeEps0,
            freeEps1
        );
    }

    continueHomoclinic(
        setup: any,
        settings: any,
        forward: boolean
    ): ContinuationBranchData {
        return this.instance.compute_homoclinic_continuation(
            setup,
            settings,
            forward
        ) as ContinuationBranchData;
    }

    continueHomotopySaddle(
        setup: any,
        settings: any,
        forward: boolean
    ): ContinuationBranchData {
        return this.instance.compute_homotopy_saddle_continuation(
            setup,
            settings,
            forward
        ) as ContinuationBranchData;
    }

    /**
     * Continues a fold (saddle-node) bifurcation curve in two-parameter space.
     * 
     * @param foldState - State vector at the fold bifurcation point
     * @param param1Name - Name of first active parameter
     * @param param1Value - Value of first parameter at fold point
     * @param param2Name - Name of second active parameter
     * @param param2Value - Value of second parameter at fold point
     * @param settings - Continuation settings
     * @param forward - Direction of continuation
     * @returns Codim-1 curve branch data
     */
    continueFoldCurve(
        foldState: number[],
        param1Name: string,
        param1Value: number,
        param2Name: string,
        param2Value: number,
        settings: any,
        forward: boolean
    ): any {
        return this.instance.continue_fold_curve(
            new Float64Array(foldState),
            param1Name,
            param1Value,
            param2Name,
            param2Value,
            settings,
            forward
        );
    }

    /**
     * Continues a Hopf bifurcation curve in two-parameter space.
     * 
     * @param hopfState - State vector at the Hopf bifurcation point
     * @param hopfOmega - Hopf frequency (imaginary part of critical eigenvalue)
     * @param param1Name - Name of first active parameter
     * @param param1Value - Value of first parameter at Hopf point
     * @param param2Name - Name of second active parameter
     * @param param2Value - Value of second parameter at Hopf point
     * @param settings - Continuation settings
     * @param forward - Direction of continuation
     * @returns Codim-1 curve branch data
     */
    continueHopfCurve(
        hopfState: number[],
        hopfOmega: number,
        param1Name: string,
        param1Value: number,
        param2Name: string,
        param2Value: number,
        settings: any,
        forward: boolean
    ): any {
        return this.instance.continue_hopf_curve(
            new Float64Array(hopfState),
            hopfOmega,
            param1Name,
            param1Value,
            param2Name,
            param2Value,
            settings,
            forward
        );
    }

    /**
     * Continues an LPC (Limit Point of Cycles) curve in two-parameter space.
     */
    continueLPCCurve(
        lcState: number[],
        period: number,
        param1Name: string,
        param1Value: number,
        param2Name: string,
        param2Value: number,
        ntst: number,
        ncol: number,
        settings: any,
        forward: boolean
    ): any {
        return this.instance.continue_lpc_curve(
            new Float64Array(lcState),
            period,
            param1Name,
            param1Value,
            param2Name,
            param2Value,
            ntst,
            ncol,
            settings,
            forward
        );
    }

    /**
     * Continues a PD (Period-Doubling) curve in two-parameter space.
     */
    continuePDCurve(
        lcState: number[],
        period: number,
        param1Name: string,
        param1Value: number,
        param2Name: string,
        param2Value: number,
        ntst: number,
        ncol: number,
        settings: any,
        forward: boolean
    ): any {
        return this.instance.continue_pd_curve(
            new Float64Array(lcState),
            period,
            param1Name,
            param1Value,
            param2Name,
            param2Value,
            ntst,
            ncol,
            settings,
            forward
        );
    }

    /**
     * Continues an NS (Neimark-Sacker) curve in two-parameter space.
     */
    continueNSCurve(
        lcState: number[],
        period: number,
        param1Name: string,
        param1Value: number,
        param2Name: string,
        param2Value: number,
        initialK: number,
        ntst: number,
        ncol: number,
        settings: any,
        forward: boolean
    ): any {
        return this.instance.continue_ns_curve(
            new Float64Array(lcState),
            period,
            param1Name,
            param1Value,
            param2Name,
            param2Value,
            initialK,
            ntst,
            ncol,
            settings,
            forward
        );
    }
}

function isCodim1BranchType(branchType: any): boolean {
    if (!branchType || typeof branchType !== 'object') {
        return false;
    }
    const type = branchType.type;
    return (
        type === 'FoldCurve' ||
        type === 'HopfCurve' ||
        type === 'LPCCurve' ||
        type === 'PDCurve' ||
        type === 'NSCurve'
    );
}

function normalizeEigenvalues(raw: unknown): ContinuationEigenvalue[] {
    if (!raw) return [];
    if (Array.isArray(raw)) {
        if (raw.length === 0) return [];
        if (typeof raw[0] === "number") {
            const nums = raw as number[];
            const result: ContinuationEigenvalue[] = [];
            for (let i = 0; i < nums.length; i += 2) {
                result.push({
                    re: nums[i] ?? 0,
                    im: nums[i + 1] ?? 0
                });
            }
            return result;
        }
        return raw.map((val: any) => {
            if (Array.isArray(val) && val.length >= 2) {
                return {
                    re: typeof val[0] === "number" ? val[0] : 0,
                    im: typeof val[1] === "number" ? val[1] : 0
                };
            }
            return {
                re: typeof val?.re === "number" ? val.re : Number(val?.re ?? 0),
                im: typeof val?.im === "number" ? val.im : Number(val?.im ?? 0)
            };
        });
    }

    if (ArrayBuffer.isView(raw)) {
        const nums = Array.from(raw as unknown as ArrayLike<number>);
        const result: ContinuationEigenvalue[] = [];
        for (let i = 0; i < nums.length; i += 2) {
            result.push({
                re: nums[i] ?? 0,
                im: nums[i + 1] ?? 0
            });
        }
        return result;
    }

    return [];
}
