import {
    EquilibriumSolution,
    SystemConfig,
    ContinuationBranchData,
    ContinuationEigenvalue,
    LimitCycleBranchResponse,
    LimitCycleMeta
} from "./types";

export type CovariantLyapunovResponse = {
    dimension: number;
    checkpoints: number;
    times: number[];
    vectors: number[];
};

// We use require to load the WASM bindings generated by wasm-pack target nodejs
let wasmModule: any;

try {
    // Path relative to compiled index.js in dist/
    // Source is in cli/src, compiled to cli/dist
    // WASM pkg is in ../crates/fork_wasm/pkg
    wasmModule = require("../../crates/fork_wasm/pkg/fork_wasm.js");
} catch (e) {
    console.warn("Could not load WASM module. Simulation will fail.", e);
}

export class WasmBridge {
    instance: any;

    constructor(config: SystemConfig) {
        if (!wasmModule) throw new Error("WASM module not loaded");

        const { equations, params, paramNames, varNames, solver, type } = config;
        const systemType = type || "flow";

        this.instance = new wasmModule.WasmSystem(
            equations,
            new Float64Array(params),
            paramNames,
            varNames,
            solver,
            systemType
        );
    }

    set_state(state: number[]) {
        this.instance.set_state(new Float64Array(state));
    }

    get_state(): number[] {
        return Array.from(this.instance.get_state());
    }

    step(dt: number) {
        this.instance.step(dt);
    }

    get_t(): number {
        return this.instance.get_t();
    }

    set_t(t: number) {
        this.instance.set_t(t);
    }

    compute_jacobian(): number[] {
        return Array.from(this.instance.compute_jacobian());
    }

    solve_equilibrium(initialGuess: number[], maxSteps: number, dampingFactor: number): EquilibriumSolution {
        const result = this.instance.solve_equilibrium(
            new Float64Array(initialGuess),
            maxSteps,
            dampingFactor
        );
        return result as EquilibriumSolution;
    }

    computeLyapunovExponents(
        startState: number[],
        startTime: number,
        steps: number,
        dt: number,
        qrStride: number
    ): number[] {
        const result = this.instance.compute_lyapunov_exponents(
            new Float64Array(startState),
            startTime,
            steps,
            dt,
            qrStride
        );
        return Array.from(result);
    }

    computeCovariantLyapunovVectors(
        startState: number[],
        startTime: number,
        windowSteps: number,
        dt: number,
        qrStride: number,
        forwardTransient: number,
        backwardTransient: number
    ): CovariantLyapunovResponse {
        return this.instance.compute_covariant_lyapunov_vectors(
            new Float64Array(startState),
            startTime,
            windowSteps,
            dt,
            qrStride,
            forwardTransient,
            backwardTransient
        ) as CovariantLyapunovResponse;
    }

    compute_continuation(
        equilibriumState: number[],
        parameterName: string,
        settings: any,
        forward: boolean
    ): ContinuationBranchData {
        return this.instance.compute_continuation(
            new Float64Array(equilibriumState),
            parameterName,
            settings,
            forward
        ) as ContinuationBranchData;
    }

    extend_continuation(
        branchData: any,
        parameterName: string,
        settings: any,
        forward: boolean
    ): ContinuationBranchData {


        // Normalize branch_type for Wasm (Rust expects internally tagged enum)
        const normalizedBranch = { ...branchData };

        // Debugging: Log what we are receiving
        // console.log("Extending branch with type:", normalizedBranch.branch_type);

        if (typeof normalizedBranch.branch_type === 'string') {
            const typeStr = (normalizedBranch.branch_type as string).toLowerCase();

            if (typeStr === 'equilibrium') {
                normalizedBranch.branch_type = { type: 'Equilibrium' };
            } else if (typeStr === 'limit_cycle') {
                // Attempt to recover LC config if possible, or assume it's lost and this will fail later
                // But typically LC branches are created with objects.
                // This handles legacy/string cases if any exist.
                // For now, if it's 'limit_cycle' string, we can't easily reconstruct without ntst/ncol.
                // Assuming standard flow creates objects.
            }
        } else if (!normalizedBranch.branch_type) {
            // Default to Equilibrium if missing

            normalizedBranch.branch_type = { type: 'Equilibrium' };
        }



        return this.instance.extend_continuation(
            normalizedBranch,
            parameterName,
            settings,
            forward
        ) as ContinuationBranchData;
    }

    compute_limit_cycle_from_hopf(
        hopfState: number[],
        hopfParam: number,
        parameterName: string,
        methodRequest: any,
        amplitude: number,
        settings: any,
        forward: boolean
    ): LimitCycleBranchResponse {
        return this.instance.continue_limit_cycle_from_hopf(
            new Float64Array(hopfState),
            hopfParam,
            parameterName,
            methodRequest,
            amplitude,
            settings,
            forward
        ) as LimitCycleBranchResponse;
    }

    extend_limit_cycle_branch(
        branchData: any,
        parameterName: string,
        meta: LimitCycleMeta,
        settings: any,
        forward: boolean
    ): LimitCycleBranchResponse {
        return this.instance.extend_limit_cycle_branch(
            branchData,
            parameterName,
            meta,
            settings,
            forward
        ) as LimitCycleBranchResponse;
    }

    computeEigenvalues(state: number[], parameterName: string, paramValue: number): ContinuationEigenvalue[] {
        const raw = this.instance.compute_equilibrium_eigenvalues(
            new Float64Array(state),
            parameterName,
            paramValue
        );
        return normalizeEigenvalues(raw);
    }

    /**
     * Initializes a limit cycle guess from a Hopf bifurcation point.
     */
    initLCFromHopf(
        hopfState: number[],
        parameterName: string,
        paramValue: number,
        amplitude: number,
        ntst: number,
        ncol: number
    ): any {
        return this.instance.init_lc_from_hopf(
            new Float64Array(hopfState),
            parameterName,
            paramValue,
            amplitude,
            ntst,
            ncol
        );
    }

    /**
     * Initializes a limit cycle guess from a computed orbit.
     * The orbit should have converged to a stable limit cycle.
     * 
     * @param orbitTimes - Time values from the orbit
     * @param orbitStates - State vectors at each time point (as 2D array)
     * @param paramValue - Current value of the continuation parameter
     * @param ntst - Number of mesh intervals
     * @param ncol - Collocation points per interval
     * @param tolerance - Tolerance for cycle detection (recurrence)
     */
    initLCFromOrbit(
        orbitTimes: number[],
        orbitStates: number[][],
        paramValue: number,
        ntst: number,
        ncol: number,
        tolerance: number
    ): any {
        // Flatten the 2D orbit states into 1D array
        const flatStates = orbitStates.flat();

        return this.instance.init_lc_from_orbit(
            new Float64Array(orbitTimes),
            new Float64Array(flatStates),
            paramValue,
            ntst,
            ncol,
            tolerance
        );
    }

    /**
     * Initializes a period-doubled limit cycle from a period-doubling bifurcation.
     * Takes the LC state at the PD point and constructs a doubled-period initial guess.
     * 
     * @param lcState - Flattened collocation state at the PD point [mesh, stages, period]
     * @param parameterName - Name of the continuation parameter
     * @param paramValue - Parameter value at the PD point
     * @param ntst - Number of mesh intervals in the source LC
     * @param ncol - Collocation points per interval
     * @param amplitude - Perturbation amplitude for stepping onto the new branch
     */
    initLCFromPD(
        lcState: number[],
        parameterName: string,
        paramValue: number,
        ntst: number,
        ncol: number,
        amplitude: number
    ): any {
        return this.instance.init_lc_from_pd(
            new Float64Array(lcState),
            parameterName,
            paramValue,
            ntst,
            ncol,
            amplitude
        );
    }

    /**
     * Continues a limit cycle from an initial guess.
     */
    continueLimitCycle(
        setup: any,
        parameterName: string,
        settings: any,
        forward: boolean
    ): ContinuationBranchData {
        return this.instance.compute_limit_cycle_continuation(
            setup,
            parameterName,
            settings,
            forward
        ) as ContinuationBranchData;
    }
}

function normalizeEigenvalues(raw: unknown): ContinuationEigenvalue[] {
    if (!raw) return [];
    if (Array.isArray(raw)) {
        if (raw.length === 0) return [];
        if (typeof raw[0] === "number") {
            const nums = raw as number[];
            const result: ContinuationEigenvalue[] = [];
            for (let i = 0; i < nums.length; i += 2) {
                result.push({
                    re: nums[i] ?? 0,
                    im: nums[i + 1] ?? 0
                });
            }
            return result;
        }
        return raw.map((val: any) => {
            if (Array.isArray(val) && val.length >= 2) {
                return {
                    re: typeof val[0] === "number" ? val[0] : 0,
                    im: typeof val[1] === "number" ? val[1] : 0
                };
            }
            return {
                re: typeof val?.re === "number" ? val.re : Number(val?.re ?? 0),
                im: typeof val?.im === "number" ? val.im : Number(val?.im ?? 0)
            };
        });
    }

    if (ArrayBuffer.isView(raw)) {
        const nums = Array.from(raw as unknown as ArrayLike<number>);
        const result: ContinuationEigenvalue[] = [];
        for (let i = 0; i < nums.length; i += 2) {
            result.push({
                re: nums[i] ?? 0,
                im: nums[i + 1] ?? 0
            });
        }
        return result;
    }

    return [];
}
